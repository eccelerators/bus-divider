-- Copyright (C) 2023 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler 1.0.19-10671667
-- VHDL Extension for HxS 1.0.21-b962bd24
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.BusDividerIfcPackage.all;

entity BusDividerBlk_BusDividerIfc is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		ReadMatch : out std_logic;
		ReadAck : out std_logic;
		ReadData : out std_logic_vector(31 downto 0);
		ReadResp : out std_logic_vector(1 downto 0);
		Read : in std_logic;
		ReadAddressMatch : in std_logic;
		ReadAddressProt : in std_logic_vector(2 downto 0);
		ReadAddress : in std_logic_vector(8 downto 0);
		WriteMatch : out std_logic;
		WriteAck : out std_logic;
		WriteResp : out std_logic_vector(1 downto 0);
		Write : in std_logic;
		WriteAddrMatch : in std_logic;
		WriteAddressProt : in std_logic_vector(2 downto 0);
		WriteAddress : in std_logic_vector(8 downto 0);
		WriteData : in std_logic_vector(31 downto 0);
		WriteStrobe : in std_logic_vector(3 downto 0);
		BusDelegate0AWVALID : out std_logic;
		BusDelegate0AWADDR : out std_logic_vector(8 downto 0);
		BusDelegate0AWPROT : out std_logic_vector(2 downto 0);
		BusDelegate0AWREADY : in std_logic;
		BusDelegate0WVALID : out std_logic;
		BusDelegate0WDATA : out std_logic_vector(31 downto 0);
		BusDelegate0WSTRB : out std_logic_vector(3 downto 0);
		BusDelegate0WREADY : in std_logic;
		BusDelegate0BREADY : out std_logic;
		BusDelegate0BVALID : in std_logic;
		BusDelegate0BRESP : in std_logic_vector(1 downto 0);
		BusDelegate0ARVALID : out std_logic;
		BusDelegate0ARADDR : out std_logic_vector(8 downto 0);
		BusDelegate0ARPROT : out std_logic_vector(2 downto 0);
		BusDelegate0ARREADY : in std_logic;
		BusDelegate0RREADY : out std_logic;
		BusDelegate0RVALID : in std_logic;
		BusDelegate0RDATA : in std_logic_vector(31 downto 0);
		BusDelegate0RRESP : in std_logic_vector(1 downto 0);
		
		BusDelegate1AWVALID : out std_logic;
		BusDelegate1AWADDR : out std_logic_vector(8 downto 0);
		BusDelegate1AWPROT : out std_logic_vector(2 downto 0);
		BusDelegate1AWREADY : in std_logic;
		BusDelegate1WVALID : out std_logic;
		BusDelegate1WDATA : out std_logic_vector(31 downto 0);
		BusDelegate1WSTRB : out std_logic_vector(3 downto 0);
		BusDelegate1WREADY : in std_logic;
		BusDelegate1BREADY : out std_logic;
		BusDelegate1BVALID : in std_logic;
		BusDelegate1BRESP : in std_logic_vector(1 downto 0);
		BusDelegate1ARVALID : out std_logic;
		BusDelegate1ARADDR : out std_logic_vector(8 downto 0);
		BusDelegate1ARPROT : out std_logic_vector(2 downto 0);
		BusDelegate1ARREADY : in std_logic;
		BusDelegate1RREADY : out std_logic;
		BusDelegate1RVALID : in std_logic;
		BusDelegate1RDATA : in std_logic_vector(31 downto 0);
		BusDelegate1RRESP : in std_logic_vector(1 downto 0)
	);
end;

architecture Behavioural of BusDividerBlk_BusDividerIfc is

	type T_BusDelegate0ReadState is (
		ReadIdleDelegateState,
		ReadAddressDelegateState,
		ReadDataDelegateState,
		ReadDoneDelegateState
	);
	
	type T_BusDelegate0WriteState is (
		WriteIdleDelegateState,
		WriteAddressDelegateState,
		WriteWaitDataDelegateState,
		WriteDataDelegateState,
		WriteRespDelegateState,
		WriteDoneDelegateState
	);
	
	signal BusDelegate0ReadState : T_BusDelegate0ReadState;
	signal BusDelegate0WriteState : T_BusDelegate0WriteState;
	
	signal BusDelegate0ReadResp : std_logic_vector(1 downto 0);
	signal BusDelegate0WriteResp : std_logic_vector(1 downto 0);
	
	signal PreReadRespBusDelegate0 : std_logic_vector(1 downto 0);
	signal PreWriteRespBusDelegate0 : std_logic_vector(1 downto 0);
	
	type T_BusDelegate1ReadState is (
		ReadIdleDelegateState,
		ReadAddressDelegateState,
		ReadDataDelegateState,
		ReadDoneDelegateState
	);
	
	type T_BusDelegate1WriteState is (
		WriteIdleDelegateState,
		WriteAddressDelegateState,
		WriteWaitDataDelegateState,
		WriteDataDelegateState,
		WriteRespDelegateState,
		WriteDoneDelegateState
	);
	
	signal BusDelegate1ReadState : T_BusDelegate1ReadState;
	signal BusDelegate1WriteState : T_BusDelegate1WriteState;
	
	signal BusDelegate1ReadResp : std_logic_vector(1 downto 0);
	signal BusDelegate1WriteResp : std_logic_vector(1 downto 0);
	
	signal PreReadRespBusDelegate1 : std_logic_vector(1 downto 0);
	signal PreWriteRespBusDelegate1 : std_logic_vector(1 downto 0);
	
	signal PreReadData : std_logic_vector(31 downto 0);
	signal PreReadDataBusDelegate0 : std_logic_vector(31 downto 0);
	signal PreReadAckBusDelegate0 : std_logic;
	signal PreWriteAckBusDelegate0 : std_logic;
	signal PreMatchReadBusDelegate0 : std_logic;
	signal PreMatchWriteBusDelegate0 : std_logic;
	
	signal PreReadDataBusDelegate1 : std_logic_vector(31 downto 0);
	signal PreReadAckBusDelegate1 : std_logic;
	signal PreWriteAckBusDelegate1 : std_logic;
	signal PreMatchReadBusDelegate1 : std_logic;
	signal PreMatchWriteBusDelegate1 : std_logic;

begin

	ReadMatch <= PreMatchReadBusDelegate0
		  or PreMatchReadBusDelegate1;
	WriteMatch <= PreMatchWriteBusDelegate0
		  or PreMatchWriteBusDelegate1;
	
	ReadAck <= PreReadAckBusDelegate0
		or PreReadAckBusDelegate1;
	
	ReadResp <= BusDelegate0ReadResp
		or BusDelegate1ReadResp;
	WriteAck <= PreWriteAckBusDelegate0
		or PreWriteAckBusDelegate1;
	
	WriteResp <= BusDelegate0WriteResp
		or BusDelegate1WriteResp;
	
	ReadData <= PreReadData;
	
	
	PreDatOutMux: process (
		PreReadDataBusDelegate0,
		PreMatchReadBusDelegate0,
		PreReadAckBusDelegate0,
		PreReadDataBusDelegate1,
		PreMatchReadBusDelegate1,
		PreReadAckBusDelegate1
	) begin
		PreReadData <= (others => '0');
		if (PreMatchReadBusDelegate0 = '1' and PreReadAckBusDelegate0 = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataBusDelegate0), PreReadData'LENGTH));
		elsif (PreMatchReadBusDelegate1 = '1' and PreReadAckBusDelegate1 = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataBusDelegate1), PreReadData'LENGTH));
		end if;
	end process;
	
	PreMatchReadBusDelegate0Process : process (ReadAddress, ReadAddressMatch)
	begin
		if ((unsigned(ReadAddress) >= unsigned(BUSDELEGATE0_BASE_ADDRESS)) and
			(unsigned(ReadAddress) <= (unsigned(BUSDELEGATE0_BASE_ADDRESS) + unsigned(BUSDELEGATE0_SIZE) - 1))) then
			PreMatchReadBusDelegate0 <= ReadAddressMatch;
		else
			PreMatchReadBusDelegate0 <= '0';
		end if;
	end process;
	
	PreMatchWriteBusDelegate0Process : process (WriteAddress, WriteAddrMatch)
	begin
		if ((unsigned(WriteAddress) >= unsigned(BUSDELEGATE0_BASE_ADDRESS)) and
			(unsigned(WriteAddress) <= (unsigned(BUSDELEGATE0_BASE_ADDRESS) + unsigned(BUSDELEGATE0_SIZE) - 1))) then
			PreMatchWriteBusDelegate0 <= WriteAddrMatch;
		else
			PreMatchWriteBusDelegate0 <= '0';
		end if;
	end process;
	
		PreReadRespBusDelegate0Process : process(PreMatchReadBusDelegate0, PreReadAckBusDelegate0, PreReadRespBusDelegate0)
		begin
			BusDelegate0ReadResp <= (others => '0');
			if (PreMatchReadBusDelegate0 = '1' and PreReadAckBusDelegate0 = '1') then
				BusDelegate0ReadResp <= PreReadRespBusDelegate0;
			end if;
		end process;
		
		PreWriteRespBusDelegate0Process : process(PreMatchWriteBusDelegate0, PreWriteAckBusDelegate0, PreWriteRespBusDelegate0)
		begin
			BusDelegate0WriteResp <= (others => '0');
			if (PreMatchWriteBusDelegate0 = '1' and PreWriteAckBusDelegate0 = '1') then
				BusDelegate0WriteResp <= PreWriteRespBusDelegate0;
			end if;
		end process;
	
		ReadRespBusDelegate0Process : process(Clk, Rst) is
		begin
			if Rst = '1' then
				BusDelegate0ARVALID <= '0';
				BusDelegate0RREADY <= '0';
				PreReadAckBusDelegate0 <= '0';
				PreReadDataBusDelegate0 <= (others => '0');
				PreReadRespBusDelegate0 <= (others => '0');
				BusDelegate0ReadState <= ReadIdleDelegateState;
			elsif rising_edge(Clk) then
				BusDelegate0ARVALID <= '0';
				BusDelegate0RREADY <= '0';
				PreReadAckBusDelegate0 <= '0';
				case BusDelegate0ReadState is
					when ReadIdleDelegateState =>
						if PreMatchReadBusDelegate0 = '1' then
							BusDelegate0ReadState <= ReadAddressDelegateState;
						end if;
					when ReadAddressDelegateState =>
						BusDelegate0ARVALID <= '1';
						if BusDelegate0ARREADY = '1' then
							BusDelegate0ReadState <= ReadDataDelegateState;
						end if;
					when ReadDataDelegateState =>
						BusDelegate0RREADY <= '1';
						PreReadDataBusDelegate0 <= BusDelegate0RDATA;
						PreReadRespBusDelegate0 <= BusDelegate0RRESP;
						if BusDelegate0RVALID = '1' then
							PreReadAckBusDelegate0 <= '1';
							BusDelegate0ReadState <= ReadDoneDelegateState;
						end if;
					when ReadDoneDelegateState =>
						BusDelegate0ReadState <= ReadIdleDelegateState;
				end case;
			end if;
		end process;
		
		WriteRespBusDelegate0Process : process(Clk, Rst) is
		begin
			if Rst = '1' then
				BusDelegate0AWVALID <= '0';
				BusDelegate0WVALID <= '0';
				BusDelegate0BREADY <= '0';
				PreWriteAckBusDelegate0 <= '0';
				PreWriteRespBusDelegate0 <= (others => '0');
				BusDelegate0WriteState <= WriteIdleDelegateState;
			elsif rising_edge(Clk) then
				BusDelegate0AWVALID <= '0';
				BusDelegate0WVALID <= '0';
				BusDelegate0BREADY <= '0';
				PreWriteAckBusDelegate0 <= '0';
				case BusDelegate0WriteState is
					when WriteIdleDelegateState =>
						if PreMatchWriteBusDelegate0 = '1' then
							BusDelegate0WriteState <= WriteAddressDelegateState;
						end if;
					when WriteAddressDelegateState =>
						BusDelegate0AWVALID <= '1';
						if BusDelegate0AWREADY = '1' then
							BusDelegate0WriteState <= WriteWaitDataDelegateState;
						end if;
					when WriteWaitDataDelegateState =>
						if Write = '1' then
							BusDelegate0WriteState <= WriteDataDelegateState;
						end if;
					when WriteDataDelegateState =>
						BusDelegate0WVALID <= '1';
						if BusDelegate0WREADY = '1' then
							BusDelegate0WriteState <= WriteRespDelegateState;
						end if;
					when WriteRespDelegateState =>
						BusDelegate0BREADY <= '1';
						PreWriteRespBusDelegate0 <= BusDelegate0BRESP;
						if BusDelegate0BVALID = '1' then
							PreWriteAckBusDelegate0 <= '1';
							BusDelegate0WriteState <= WriteDoneDelegateState;
						end if;
					when WriteDoneDelegateState =>
						BusDelegate0WriteState <= WriteIdleDelegateState;
				end case;
			end if;
		end process;
		
		BusDelegate0AWADDR <= WriteAddress;
		BusDelegate0AWPROT <= WriteAddressProt;
		BusDelegate0WDATA <= WriteData;
		BusDelegate0WSTRB <= WriteStrobe;
		BusDelegate0ARADDR <= ReadAddress;
		BusDelegate0ARPROT <= ReadAddressProt;
	
	PreMatchReadBusDelegate1Process : process (ReadAddress, ReadAddressMatch)
	begin
		if ((unsigned(ReadAddress) >= unsigned(BUSDELEGATE1_BASE_ADDRESS)) and
			(unsigned(ReadAddress) <= (unsigned(BUSDELEGATE1_BASE_ADDRESS) + unsigned(BUSDELEGATE1_SIZE) - 1))) then
			PreMatchReadBusDelegate1 <= ReadAddressMatch;
		else
			PreMatchReadBusDelegate1 <= '0';
		end if;
	end process;
	
	PreMatchWriteBusDelegate1Process : process (WriteAddress, WriteAddrMatch)
	begin
		if ((unsigned(WriteAddress) >= unsigned(BUSDELEGATE1_BASE_ADDRESS)) and
			(unsigned(WriteAddress) <= (unsigned(BUSDELEGATE1_BASE_ADDRESS) + unsigned(BUSDELEGATE1_SIZE) - 1))) then
			PreMatchWriteBusDelegate1 <= WriteAddrMatch;
		else
			PreMatchWriteBusDelegate1 <= '0';
		end if;
	end process;
	
		PreReadRespBusDelegate1Process : process(PreMatchReadBusDelegate1, PreReadAckBusDelegate1, PreReadRespBusDelegate1)
		begin
			BusDelegate1ReadResp <= (others => '0');
			if (PreMatchReadBusDelegate1 = '1' and PreReadAckBusDelegate1 = '1') then
				BusDelegate1ReadResp <= PreReadRespBusDelegate1;
			end if;
		end process;
		
		PreWriteRespBusDelegate1Process : process(PreMatchWriteBusDelegate1, PreWriteAckBusDelegate1, PreWriteRespBusDelegate1)
		begin
			BusDelegate1WriteResp <= (others => '0');
			if (PreMatchWriteBusDelegate1 = '1' and PreWriteAckBusDelegate1 = '1') then
				BusDelegate1WriteResp <= PreWriteRespBusDelegate1;
			end if;
		end process;
	
		ReadRespBusDelegate1Process : process(Clk, Rst) is
		begin
			if Rst = '1' then
				BusDelegate1ARVALID <= '0';
				BusDelegate1RREADY <= '0';
				PreReadAckBusDelegate1 <= '0';
				PreReadDataBusDelegate1 <= (others => '0');
				PreReadRespBusDelegate1 <= (others => '0');
				BusDelegate1ReadState <= ReadIdleDelegateState;
			elsif rising_edge(Clk) then
				BusDelegate1ARVALID <= '0';
				BusDelegate1RREADY <= '0';
				PreReadAckBusDelegate1 <= '0';
				case BusDelegate1ReadState is
					when ReadIdleDelegateState =>
						if PreMatchReadBusDelegate1 = '1' then
							BusDelegate1ReadState <= ReadAddressDelegateState;
						end if;
					when ReadAddressDelegateState =>
						BusDelegate1ARVALID <= '1';
						if BusDelegate1ARREADY = '1' then
							BusDelegate1ReadState <= ReadDataDelegateState;
						end if;
					when ReadDataDelegateState =>
						BusDelegate1RREADY <= '1';
						PreReadDataBusDelegate1 <= BusDelegate1RDATA;
						PreReadRespBusDelegate1 <= BusDelegate1RRESP;
						if BusDelegate1RVALID = '1' then
							PreReadAckBusDelegate1 <= '1';
							BusDelegate1ReadState <= ReadDoneDelegateState;
						end if;
					when ReadDoneDelegateState =>
						BusDelegate1ReadState <= ReadIdleDelegateState;
				end case;
			end if;
		end process;
		
		WriteRespBusDelegate1Process : process(Clk, Rst) is
		begin
			if Rst = '1' then
				BusDelegate1AWVALID <= '0';
				BusDelegate1WVALID <= '0';
				BusDelegate1BREADY <= '0';
				PreWriteAckBusDelegate1 <= '0';
				PreWriteRespBusDelegate1 <= (others => '0');
				BusDelegate1WriteState <= WriteIdleDelegateState;
			elsif rising_edge(Clk) then
				BusDelegate1AWVALID <= '0';
				BusDelegate1WVALID <= '0';
				BusDelegate1BREADY <= '0';
				PreWriteAckBusDelegate1 <= '0';
				case BusDelegate1WriteState is
					when WriteIdleDelegateState =>
						if PreMatchWriteBusDelegate1 = '1' then
							BusDelegate1WriteState <= WriteAddressDelegateState;
						end if;
					when WriteAddressDelegateState =>
						BusDelegate1AWVALID <= '1';
						if BusDelegate1AWREADY = '1' then
							BusDelegate1WriteState <= WriteWaitDataDelegateState;
						end if;
					when WriteWaitDataDelegateState =>
						if Write = '1' then
							BusDelegate1WriteState <= WriteDataDelegateState;
						end if;
					when WriteDataDelegateState =>
						BusDelegate1WVALID <= '1';
						if BusDelegate1WREADY = '1' then
							BusDelegate1WriteState <= WriteRespDelegateState;
						end if;
					when WriteRespDelegateState =>
						BusDelegate1BREADY <= '1';
						PreWriteRespBusDelegate1 <= BusDelegate1BRESP;
						if BusDelegate1BVALID = '1' then
							PreWriteAckBusDelegate1 <= '1';
							BusDelegate1WriteState <= WriteDoneDelegateState;
						end if;
					when WriteDoneDelegateState =>
						BusDelegate1WriteState <= WriteIdleDelegateState;
				end case;
			end if;
		end process;
		
		BusDelegate1AWADDR <= WriteAddress;
		BusDelegate1AWPROT <= WriteAddressProt;
		BusDelegate1WDATA <= WriteData;
		BusDelegate1WSTRB <= WriteStrobe;
		BusDelegate1ARADDR <= ReadAddress;
		BusDelegate1ARPROT <= ReadAddressProt;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity BusDividerIfcAxi4LiteBusController is
	port(
		Clk : in std_logic;
		Rst : in std_logic;
		AWVALID : in std_logic;
		AWADDR : in std_logic_vector(8 downto 0);
		AWPROT : in std_logic_vector(2 downto 0);
		AWREADY : out std_logic;
		WVALID : in std_logic;
		WDATA : in std_logic_vector(31 downto 0);
		WSTRB : in std_logic_vector(3 downto 0);
		WREADY : out std_logic;
		BREADY : in std_logic;
		BVALID : out std_logic;
		BRESP : out std_logic_vector(1 downto 0);
		ARVALID : in std_logic;
		ARADDR : in std_logic_vector(8 downto 0);
		ARPROT : in std_logic_vector(2 downto 0);
		ARREADY : out std_logic;
		RREADY : in std_logic;
		RVALID : out std_logic;
		RDATA : out std_logic_vector(31 downto 0);
		RRESP : out std_logic_vector(1 downto 0);
		WritePrivileged : out std_logic;
		WriteSecure : out std_logic;
		WriteInstruction : out std_logic;
		ReadPrivileged : out std_logic;
		ReadSecure : out std_logic;
		ReadInstruction : out std_logic;
		ReadMatch : in std_logic;
		ReadAck : in std_logic;
		ReadData : in std_logic_vector(31 downto 0);
		ReadResp : in std_logic_vector(1 downto 0);
		Read : out std_logic;
		ReadAddressMatch : out std_logic;
		ReadAddressProt : out std_logic_vector(2 downto 0);
		ReadAddress : out std_logic_vector(8 downto 0);
		WriteMatch : in std_logic;
		WriteAck : in std_logic;
		WriteResp : in std_logic_vector(1 downto 0);
		Write : out std_logic;
		WriteAddrMatch : out std_logic;
		WriteAddressProt : out std_logic_vector(2 downto 0);
		WriteAddress : out std_logic_vector(8 downto 0);
		WriteData : out std_logic_vector(31 downto 0);
		WriteStrobe : out std_logic_vector(3 downto 0);
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of BusDividerIfcAxi4LiteBusController is

	type T_Axi4LiteWriteState is (
		Axi4LiteWriteStateIdle,
		Axi4LiteWriteStateAddress,
		Axi4LiteWriteStateData,
		Axi4LiteWriteStateResp,
		Axi4LiteWriteStateErrorResp,
		Axi4LiteWriteStateDone
	);

	type T_Axi4LiteReadState is (
		Axi4LiteReadStateIdle,
		Axi4LiteReadStateAddress,
		Axi4LiteReadStateData,
		Axi4LiteReadStateDone
	);

	signal Axi4LiteReadState : T_Axi4LiteReadState;
	signal Axi4LiteWriteState : T_Axi4LiteWriteState;

	signal ReadTimeoutCounter : unsigned(9 downto 0);
	signal WriteTimeoutCounter : unsigned(9 downto 0);

	signal ReadUnoccupiedAck : std_logic;
	signal WriteUnoccupiedAck : std_logic;
	signal ReadTimeoutAck : std_logic;
	signal WriteTimeoutAck : std_logic;
	
	signal ReadProtect : std_logic_vector(2 downto 0);
	signal WriteProtect : std_logic_vector(2 downto 0);

begin

	UnoccupiedAck <= ReadUnoccupiedAck or WriteUnoccupiedAck;
	TimeoutAck <= ReadTimeoutAck or WriteTimeoutAck;

	WritePrivileged <= WriteProtect(0);
	WriteSecure <= WriteProtect(1);
	WriteInstruction <= WriteProtect(2);
	ReadPrivileged <= ReadProtect(0);
	ReadSecure <= ReadProtect(1);
	ReadInstruction <= ReadProtect(2);
	
	WriteAddressProt <= WriteProtect;
	ReadAddressProt <= ReadProtect;

	Axi4LiteRead : process(Clk, Rst) is
	begin
		if Rst = '1' then
			ARREADY <= '0';
			RVALID <= '0';
			RDATA <= (others => '0');
			RRESP <= (others => '0');
			Read <= '0';
			ReadAddressMatch <= '0';
			ReadAddress <= (others => '0');
			ReadProtect <= (others => '0');
			ReadUnoccupiedAck <= '0';
			ReadTimeoutAck <= '0';
			ReadTimeoutCounter <= (others => '1');
			Axi4LiteReadState <= Axi4LiteReadStateIdle;
		elsif rising_edge(Clk) then
			ARREADY <= '0';
			RVALID <= '0';
			case Axi4LiteReadState is
				when Axi4LiteReadStateIdle =>
					ReadUnoccupiedAck <= '0';
					ReadTimeoutAck <= '0';
					ReadTimeoutCounter <= (others => '1');
					Read <= '0';
					ReadAddressMatch <= '0';
					ReadAddress <= (others => '0');
					ReadProtect <= (others => '0');
					if ARVALID = '1' then
						ReadAddress <= ARADDR;
						ReadProtect <= ARPROT;
						ReadAddressMatch <= '1';
						Axi4LiteReadState <= Axi4LiteReadStateAddress;
					end if;
				when Axi4LiteReadStateAddress =>
					ARREADY <= '1';
					Axi4LiteReadState <= Axi4LiteReadStateData;
					if ReadMatch = '1' then
						Read <= '1';
					else
						ReadUnoccupiedAck <= '1';
					end if;
				when Axi4LiteReadStateData =>
					ReadTimeoutCounter <= ReadTimeoutCounter - 1;
					RDATA <= ReadData;
					RRESP <= ReadResp;
					if ReadAck = '1' then
						ReadAddressMatch <= '0';
						RVALID <= '1';
						Axi4LiteReadState <= Axi4LiteReadStateDone;
					end if;
					if ReadUnoccupiedAck = '1' then
						RRESP <= "11";
						RVALID <= '1';
						ReadAddressMatch <= '0';
						Axi4LiteReadState <= Axi4LiteReadStateDone;
					end if;
					if ReadTimeoutCounter = 0 then
						ReadTimeoutAck <= '1';
						RRESP <= "10";
						RVALID <= '1';
						ReadAddressMatch <= '0';
						Axi4LiteReadState <= Axi4LiteReadStateDone;
					end if;
				when Axi4LiteReadStateDone =>
					RVALID <= '1';
					if RREADY = '1' then
						RVALID <= '0';
						ReadAddress <= (others => '0');
						ReadProtect <= (others => '0');
						RRESP <= (others => '0');
						Read <= '0';
						Axi4LiteReadState <= Axi4LiteReadStateIdle;
					end if;
			end case;
		end if;
	end process;

	Axi4LiteWrite : process(Clk, Rst) is
	begin
		if Rst = '1' then
			AWREADY <= '0';
			WREADY <= '0';
			BVALID <= '0';
			BRESP <= (others => '0');
			Write <= '0';
			WriteAddrMatch <= '0';
			WriteAddress <= (others => '0');
			WriteProtect <= (others => '0');
			WriteData <= (others => '0');
			WriteStrobe <= (others => '0');
			WriteUnoccupiedAck <= '0';
			WriteTimeoutAck <= '0';
			WriteTimeoutCounter <= (others => '1');
			Axi4LiteWriteState <= Axi4LiteWriteStateIdle;
		elsif rising_edge(Clk) then
			AWREADY <= '0';
			WREADY <= '0';
			BVALID <= '0';
			case Axi4LiteWriteState is
				when Axi4LiteWriteStateIdle =>
					WriteUnoccupiedAck <= '0';
					WriteTimeoutAck <= '0';
					WriteTimeoutCounter <= (others => '1');
					Write <= '0';
					WriteAddrMatch <= '0';
					WriteAddress <= (others => '0');
					WriteProtect <= (others => '0');
					if AWVALID = '1' then
						WriteAddress <= AWADDR;
						WriteProtect <= AWPROT;
						WriteAddrMatch <= '1';
						Axi4LiteWriteState <= Axi4LiteWriteStateAddress;
					end if;
				when Axi4LiteWriteStateAddress =>
					AWREADY <= '1';
					WREADY <= '1';
					Axi4LiteWriteState <= Axi4LiteWriteStateData;
					if WriteMatch = '0' then
						WriteUnoccupiedAck <= '1';
					end if;
				when Axi4LiteWriteStateData =>
					WREADY <= '1';
					WriteData <= WDATA;
					WriteStrobe <= WSTRB;
					if WVALID = '1' then
						WREADY <= '0';
						if WriteUnoccupiedAck = '0' then
							Write <= '1';
							Axi4LiteWriteState <= Axi4LiteWriteStateResp;
						else
							Axi4LiteWriteState <= Axi4LiteWriteStateErrorResp;
						end if;
					end if;
				when Axi4LiteWriteStateResp =>
					WriteTimeoutCounter <= WriteTimeoutCounter - 1;
					Write <= '1';
					BRESP <= WriteResp;
					if WriteAck = '1' then
						Write <= '0';
						WriteAddrMatch <= '0';
						BVALID <= '1';
						Axi4LiteWriteState <= Axi4LiteWriteStateDone;
					end if;
					if WriteTimeoutCounter = 0 then
						WriteTimeoutAck <= '1';
						Write <= '0';
						WriteAddrMatch <= '0';
						Axi4LiteWriteState <= Axi4LiteWriteStateErrorResp;
					end if;
				when Axi4LiteWriteStateErrorResp =>
					Write <= '0';
					WriteAddrMatch <= '0';
					BVALID <= '1';
					Axi4LiteWriteState <= Axi4LiteWriteStateDone;
					if WriteUnoccupiedAck = '1' then
						BRESP <= "11";
					else
						BRESP <= "10";
					end if;
				when Axi4LiteWriteStateDone =>
					BVALID <= '1';
					if BREADY = '1' then
						WriteAddress <= (others => '0');
						WriteProtect <= (others => '0');
						BVALID <= '0';
						BRESP <= (others => '0');
						Axi4LiteWriteState <= Axi4LiteWriteStateIdle;
					end if;
			end case;
		end if;
	end process;

end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.BusDividerIfcPackage.all;

entity BusDividerIfcAxi4Lite is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Axi4LiteDown : in T_BusDividerIfcAxi4LiteDown;
		Axi4LiteUp : out T_BusDividerIfcAxi4LiteUp;
		Axi4LiteAccess : out T_BusDividerIfcAxi4LiteAccess;
		Trace : out T_BusDividerIfcTrace;
		BusDividerBlkDown : out T_BusDividerIfcBusDividerBlkDown;
		BusDividerBlkUp : in T_BusDividerIfcBusDividerBlkUp
	);
end;

architecture Behavioural of BusDividerIfcAxi4Lite is

	signal PreAxi4LiteUp : T_BusDividerIfcAxi4LiteUp;
	signal PreAxi4LiteAccess : T_BusDividerIfcAxi4LiteAccess;
	
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal ReadMatch : std_logic;
	signal ReadAck : std_logic;
	signal ReadData : std_logic_vector(31 downto 0);
	signal ReadResp : std_logic_vector(1 downto 0);
	signal Read : std_logic;
	signal ReadAddressMatch : std_logic;
	signal ReadAddressProt : std_logic_vector(2 downto 0);
	signal ReadAddress : std_logic_vector(8 downto 0);
	signal WriteMatch : std_logic;
	signal WriteAck : std_logic;
	signal WriteResp : std_logic_vector(1 downto 0);
	signal Write : std_logic;
	signal WriteAddrMatch : std_logic;
	signal WriteAddressProt : std_logic_vector(2 downto 0);
	signal WriteAddress : std_logic_vector(8 downto 0);
	signal WriteData : std_logic_vector(31 downto 0);
	signal WriteStrobe : std_logic_vector(3 downto 0);
	
	signal BusDividerBlkReadMatch : std_logic;
	signal BusDividerBlkReadAck : std_logic;
	signal BusDividerBlkReadData : std_logic_vector(31 downto 0);
	signal BusDividerBlkReadResp : std_logic_vector(1 downto 0);
	signal BusDividerBlkWriteMatch : std_logic;
	signal BusDividerBlkWriteAck : std_logic;
	signal BusDividerBlkWriteResp : std_logic_vector(1 downto 0);

begin

	i_BusDividerIfcAxi4LiteBusController : entity work.BusDividerIfcAxi4LiteBusController
		port map (
			Clk => Clk,
			Rst => Rst,
			AWVALID => Axi4LiteDown.AWVALID,
			AWADDR => Axi4LiteDown.AWADDR,
			AWPROT => Axi4LiteDown.AWPROT,
			AWREADY => PreAxi4LiteUp.AWREADY,
			WVALID => Axi4LiteDown.WVALID,
			WDATA => Axi4LiteDown.WDATA,
			WSTRB => Axi4LiteDown.WSTRB,
			WREADY => PreAxi4LiteUp.WREADY,
			BREADY => Axi4LiteDown.BREADY,
			BVALID => PreAxi4LiteUp.BVALID,
			BRESP => PreAxi4LiteUp.BRESP,
			ARVALID => Axi4LiteDown.ARVALID,
			ARADDR => Axi4LiteDown.ARADDR,
			ARPROT => Axi4LiteDown.ARPROT,
			ARREADY => PreAxi4LiteUp.ARREADY,
			RREADY => Axi4LiteDown.RREADY,
			RVALID => PreAxi4LiteUp.RVALID,
			RDATA => PreAxi4LiteUp.RDATA,
			RRESP => PreAxi4LiteUp.RRESP,
			WritePrivileged => PreAxi4LiteAccess.WritePrivileged,
			WriteSecure => PreAxi4LiteAccess.WriteSecure,
			WriteInstruction => PreAxi4LiteAccess.WriteInstruction,
			ReadPrivileged => PreAxi4LiteAccess.ReadPrivileged,
			ReadSecure => PreAxi4LiteAccess.ReadSecure,
			ReadInstruction => PreAxi4LiteAccess.ReadInstruction,
			ReadMatch => ReadMatch,
			ReadAck => ReadAck,
			ReadData => ReadData,
			ReadResp => ReadResp,
			Read => Read,
			ReadAddressMatch => ReadAddressMatch,
			ReadAddressProt => ReadAddressProt,
			ReadAddress => ReadAddress,
			WriteMatch => WriteMatch,
			WriteAck => WriteAck,
			WriteResp => WriteResp,
			Write => Write,
			WriteAddrMatch => WriteAddrMatch,
			WriteAddressProt => WriteAddressProt,
			WriteAddress => WriteAddress,
			WriteData => WriteData,
			WriteStrobe => WriteStrobe,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_BusDividerBlk_BusDividerIfc : entity work.BusDividerBlk_BusDividerIfc
		port map (
			Clk => Clk,
			Rst => Rst,
			ReadMatch => BusDividerBlkReadMatch,
			ReadAck => BusDividerBlkReadAck,
			ReadData => BusDividerBlkReadData,
			ReadResp => BusDividerBlkReadResp,
			Read => Read,
			ReadAddressMatch => ReadAddressMatch,
			ReadAddressProt => ReadAddressProt,
			ReadAddress => ReadAddress,
			WriteMatch => BusDividerBlkWriteMatch,
			WriteAck => BusDividerBlkWriteAck,
			WriteResp => BusDividerBlkWriteResp,
			Write => Write,
			WriteAddrMatch => WriteAddrMatch,
			WriteAddressProt => WriteAddressProt,
			WriteAddress => WriteAddress,
			WriteData => WriteData,
			WriteStrobe => WriteStrobe,
			BusDelegate0AWVALID => BusDividerBlkDown.BusDelegate0AWVALID,
			BusDelegate0AWADDR => BusDividerBlkDown.BusDelegate0AWADDR,
			BusDelegate0AWPROT => BusDividerBlkDown.BusDelegate0AWPROT,
			BusDelegate0AWREADY => BusDividerBlkUp.BusDelegate0AWREADY,
			BusDelegate0WVALID => BusDividerBlkDown.BusDelegate0WVALID,
			BusDelegate0WDATA => BusDividerBlkDown.BusDelegate0WDATA,
			BusDelegate0WSTRB => BusDividerBlkDown.BusDelegate0WSTRB,
			BusDelegate0WREADY => BusDividerBlkUp.BusDelegate0WREADY,
			BusDelegate0BREADY => BusDividerBlkDown.BusDelegate0BREADY,
			BusDelegate0BVALID => BusDividerBlkUp.BusDelegate0BVALID,
			BusDelegate0BRESP => BusDividerBlkUp.BusDelegate0BRESP,
			BusDelegate0ARVALID => BusDividerBlkDown.BusDelegate0ARVALID,
			BusDelegate0ARADDR => BusDividerBlkDown.BusDelegate0ARADDR,
			BusDelegate0ARPROT => BusDividerBlkDown.BusDelegate0ARPROT,
			BusDelegate0ARREADY => BusDividerBlkUp.BusDelegate0ARREADY,
			BusDelegate0RREADY => BusDividerBlkDown.BusDelegate0RREADY,
			BusDelegate0RVALID => BusDividerBlkUp.BusDelegate0RVALID,
			BusDelegate0RDATA => BusDividerBlkUp.BusDelegate0RDATA,
			BusDelegate0RRESP => BusDividerBlkUp.BusDelegate0RRESP,
			BusDelegate1AWVALID => BusDividerBlkDown.BusDelegate1AWVALID,
			BusDelegate1AWADDR => BusDividerBlkDown.BusDelegate1AWADDR,
			BusDelegate1AWPROT => BusDividerBlkDown.BusDelegate1AWPROT,
			BusDelegate1AWREADY => BusDividerBlkUp.BusDelegate1AWREADY,
			BusDelegate1WVALID => BusDividerBlkDown.BusDelegate1WVALID,
			BusDelegate1WDATA => BusDividerBlkDown.BusDelegate1WDATA,
			BusDelegate1WSTRB => BusDividerBlkDown.BusDelegate1WSTRB,
			BusDelegate1WREADY => BusDividerBlkUp.BusDelegate1WREADY,
			BusDelegate1BREADY => BusDividerBlkDown.BusDelegate1BREADY,
			BusDelegate1BVALID => BusDividerBlkUp.BusDelegate1BVALID,
			BusDelegate1BRESP => BusDividerBlkUp.BusDelegate1BRESP,
			BusDelegate1ARVALID => BusDividerBlkDown.BusDelegate1ARVALID,
			BusDelegate1ARADDR => BusDividerBlkDown.BusDelegate1ARADDR,
			BusDelegate1ARPROT => BusDividerBlkDown.BusDelegate1ARPROT,
			BusDelegate1ARREADY => BusDividerBlkUp.BusDelegate1ARREADY,
			BusDelegate1RREADY => BusDividerBlkDown.BusDelegate1RREADY,
			BusDelegate1RVALID => BusDividerBlkUp.BusDelegate1RVALID,
			BusDelegate1RDATA => BusDividerBlkUp.BusDelegate1RDATA,
			BusDelegate1RRESP => BusDividerBlkUp.BusDelegate1RRESP
		);
	
	Axi4LiteUp <= PreAxi4LiteUp;
	Axi4LiteAccess <= PreAxi4LiteAccess;
	
	Trace.Axi4LiteDown <= Axi4LiteDown;
	Trace.Axi4LiteUp <= PreAxi4LiteUp;
	Trace.Axi4LiteAccess <= PreAxi4LiteAccess;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	ReadMatch <= BusDividerBlkReadMatch;
	ReadAck <= BusDividerBlkReadAck;
	ReadResp <= BusDividerBlkReadResp;
	ReadData <= BusDividerBlkReadData;
	WriteMatch <= BusDividerBlkWriteMatch;
	WriteAck <= BusDividerBlkWriteAck;
	WriteResp <= BusDividerBlkWriteResp;

end;
