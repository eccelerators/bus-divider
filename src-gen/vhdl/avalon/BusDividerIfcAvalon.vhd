-- Copyright (C) 2023 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler 1.0.19-10671667
-- VHDL Extension for HxS 1.0.21-b962bd24
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.BusDividerIfcPackage.all;

entity BusDividerBlk_BusDividerIfc is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Address : in std_logic_vector(8 downto 0);
		ByteEnable : in std_logic_vector(3 downto 0);
		Read : in std_logic;
		ReadData : out std_logic_vector(31 downto 0);
		Write : in std_logic;
		WriteData : in std_logic_vector(31 downto 0);
		WaitRequest : out std_logic;
		Match : out std_logic;
		BusDelegate0Address : out std_logic_vector(8 downto 0);
		BusDelegate0ByteEnable : out std_logic_vector(3 downto 0);
		BusDelegate0Read : out std_logic;
		BusDelegate0ReadData : in std_logic_vector(31 downto 0);
		BusDelegate0Write : out std_logic;
		BusDelegate0WriteData: out std_logic_vector(31 downto 0);
		BusDelegate0WaitRequest : in std_logic;
		
		BusDelegate1Address : out std_logic_vector(8 downto 0);
		BusDelegate1ByteEnable : out std_logic_vector(3 downto 0);
		BusDelegate1Read : out std_logic;
		BusDelegate1ReadData : in std_logic_vector(31 downto 0);
		BusDelegate1Write : out std_logic;
		BusDelegate1WriteData: out std_logic_vector(31 downto 0);
		BusDelegate1WaitRequest : in std_logic
	);
end;

architecture Behavioural of BusDividerBlk_BusDividerIfc is

	signal PreReadData : std_logic_vector(31 downto 0);
	signal PreReadDataBusDelegate0 : std_logic_vector(31 downto 0);
	signal PreAckBusDelegate0 : std_logic;
	signal PreMatchReadBusDelegate0 : std_logic;
	signal PreMatchWriteBusDelegate0 : std_logic;
	
	signal PreReadDataBusDelegate1 : std_logic_vector(31 downto 0);
	signal PreAckBusDelegate1 : std_logic;
	signal PreMatchReadBusDelegate1 : std_logic;
	signal PreMatchWriteBusDelegate1 : std_logic;

begin

	ReadData <= PreReadData;
	
	Match <= PreMatchReadBusDelegate0 or PreMatchWriteBusDelegate0
		  or PreMatchReadBusDelegate1 or PreMatchWriteBusDelegate1;
	
	WaitRequest <= not (PreAckBusDelegate0
		or PreAckBusDelegate1);
	
	PreDatOutMux: process (
		PreReadDataBusDelegate0,
		PreMatchReadBusDelegate0,
		PreAckBusDelegate0,
		PreReadDataBusDelegate1,
		PreMatchReadBusDelegate1,
		PreAckBusDelegate1
	) begin
		PreReadData <= (others => '0');
		if (PreMatchReadBusDelegate0 = '1' and PreAckBusDelegate0 = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataBusDelegate0), PreReadData'LENGTH));
		elsif (PreMatchReadBusDelegate1 = '1' and PreAckBusDelegate1 = '1') then
			PreReadData <= std_logic_vector(resize(unsigned(PreReadDataBusDelegate1), PreReadData'LENGTH));
		end if;
	end process;
	
	PreMatchReadBusDelegate0Process : process (Address, Read)
	begin
		if ((unsigned(Address) >= unsigned(BUSDELEGATE0_BASE_ADDRESS)) and
			(unsigned(Address) <= (unsigned(BUSDELEGATE0_BASE_ADDRESS) + unsigned(BUSDELEGATE0_SIZE) - 1))) then
			PreMatchReadBusDelegate0 <= Read;
		else
			PreMatchReadBusDelegate0 <= '0';
		end if;
	end process;
	
	PreMatchWriteBusDelegate0Process : process (Address, Write)
	begin
		if ((unsigned(Address) >= unsigned(BUSDELEGATE0_BASE_ADDRESS)) and
			(unsigned(Address) <= (unsigned(BUSDELEGATE0_BASE_ADDRESS) + unsigned(BUSDELEGATE0_SIZE) - 1))) then
			PreMatchWriteBusDelegate0 <= Write;
		else
			PreMatchWriteBusDelegate0 <= '0';
		end if;
	end process;
	
	BusDelegate0Address <= Address;
	BusDelegate0ByteEnable <= ByteEnable;
	BusDelegate0Read <= PreMatchReadBusDelegate0;
	PreReadDataBusDelegate0 <= BusDelegate0ReadData;
	BusDelegate0Write <= PreMatchWriteBusDelegate0;
	BusDelegate0WriteData <= WriteData;
	PreAckBusDelegate0 <= not BusDelegate0WaitRequest;
	
	PreMatchReadBusDelegate1Process : process (Address, Read)
	begin
		if ((unsigned(Address) >= unsigned(BUSDELEGATE1_BASE_ADDRESS)) and
			(unsigned(Address) <= (unsigned(BUSDELEGATE1_BASE_ADDRESS) + unsigned(BUSDELEGATE1_SIZE) - 1))) then
			PreMatchReadBusDelegate1 <= Read;
		else
			PreMatchReadBusDelegate1 <= '0';
		end if;
	end process;
	
	PreMatchWriteBusDelegate1Process : process (Address, Write)
	begin
		if ((unsigned(Address) >= unsigned(BUSDELEGATE1_BASE_ADDRESS)) and
			(unsigned(Address) <= (unsigned(BUSDELEGATE1_BASE_ADDRESS) + unsigned(BUSDELEGATE1_SIZE) - 1))) then
			PreMatchWriteBusDelegate1 <= Write;
		else
			PreMatchWriteBusDelegate1 <= '0';
		end if;
	end process;
	
	BusDelegate1Address <= Address;
	BusDelegate1ByteEnable <= ByteEnable;
	BusDelegate1Read <= PreMatchReadBusDelegate1;
	PreReadDataBusDelegate1 <= BusDelegate1ReadData;
	BusDelegate1Write <= PreMatchWriteBusDelegate1;
	BusDelegate1WriteData <= WriteData;
	PreAckBusDelegate1 <= not BusDelegate1WaitRequest;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity BusDividerIfcBusMonitor is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Read : in  std_logic;
		Write : in  std_logic;
		Match : in std_logic;
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of BusDividerIfcBusMonitor is

	signal BusAccessDelay : std_logic;
	signal BusAccess : std_logic;
	signal PreUnoccupiedAck : std_logic;
	signal PreTimeoutAck : std_logic;
	signal TimeoutCounter : unsigned(9 downto 0);

begin

	BusAccess <= Read or Write;

	BusAccessDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			BusAccessDelay <= '0';
		elsif rising_edge(Clk) then
			BusAccessDelay <= BusAccess;
		end if;
	end process;

	MatchDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreUnoccupiedAck <= '0';
		elsif rising_edge(Clk) then
			PreUnoccupiedAck <= '0';
			if ((BusAccess = '1') and (BusAccessDelay = '1') and (Match = '0')) then
				PreUnoccupiedAck <= not PreUnoccupiedAck;
			end if;
		end if;
	end process;
	
	TimeoutDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreTimeoutAck <= '0';
			TimeoutCounter <= (others => '1');
		elsif rising_edge(Clk) then
			PreTimeoutAck <= '0';
			TimeoutCounter <= (others => '1');
			if ((BusAccess = '1') and (BusAccessDelay = '1') and (Match = '1')) then
				if (TimeoutCounter = 0) then
					PreTimeoutAck <= not PreTimeoutAck;
				else
					TimeoutCounter <= TimeoutCounter - 1;
				end if;
			end if;
		end if;
	end process;

	UnoccupiedAck <= PreUnoccupiedAck;
	TimeoutAck <= PreTimeoutAck;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.BusDividerIfcPackage.all;

entity BusDividerIfcAvalon is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		AvalonDown : in T_BusDividerIfcAvalonDown;
		AvalonUp : out T_BusDividerIfcAvalonUp;
		Trace : out T_BusDividerIfcTrace;
		BusDividerBlkDown : out T_BusDividerIfcBusDividerBlkDown;
		BusDividerBlkUp : in T_BusDividerIfcBusDividerBlkUp
	);
end;

architecture Behavioural of BusDividerIfcAvalon is

	signal BlockMatch : std_logic;
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal PreAvalonUp : T_BusDividerIfcAvalonUp;
	
	signal BusDividerBlkReadData : std_logic_vector(31 downto 0);
	signal BusDividerBlkWaitRequest : std_logic;
	signal BusDividerBlkMatch : std_logic;

begin

	i_BusDividerIfcBusMonitor : entity work.BusDividerIfcBusMonitor
		port map (
			Clk => Clk,
			Rst => Rst,
			Read => AvalonDown.Read,
			Write => AvalonDown.Write,
			Match => BlockMatch,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_BusDividerBlk_BusDividerIfc : entity work.BusDividerBlk_BusDividerIfc
		port map (
			Clk => Clk,
			Rst => Rst,
			Address => AvalonDown.Address,
			ByteEnable => AvalonDown.ByteEnable,
			Read => AvalonDown.Read,
			ReadData =>  BusDividerBlkReadData,
			Write => AvalonDown.Write,
			WriteData => AvalonDown.WriteData,
			WaitRequest => BusDividerBlkWaitRequest,
			Match => BusDividerBlkMatch,
			BusDelegate0Address => BusDividerBlkDown.BusDelegate0Address,
			BusDelegate0ByteEnable => BusDividerBlkDown.BusDelegate0ByteEnable,
			BusDelegate0Read => BusDividerBlkDown.BusDelegate0Read,
			BusDelegate0ReadData => BusDividerBlkUp.BusDelegate0ReadData,
			BusDelegate0Write => BusDividerBlkDown.BusDelegate0Write,
			BusDelegate0WriteData => BusDividerBlkDown.BusDelegate0WriteData,
			BusDelegate0WaitRequest => BusDividerBlkUp.BusDelegate0WaitRequest,
			BusDelegate1Address => BusDividerBlkDown.BusDelegate1Address,
			BusDelegate1ByteEnable => BusDividerBlkDown.BusDelegate1ByteEnable,
			BusDelegate1Read => BusDividerBlkDown.BusDelegate1Read,
			BusDelegate1ReadData => BusDividerBlkUp.BusDelegate1ReadData,
			BusDelegate1Write => BusDividerBlkDown.BusDelegate1Write,
			BusDelegate1WriteData => BusDividerBlkDown.BusDelegate1WriteData,
			BusDelegate1WaitRequest => BusDividerBlkUp.BusDelegate1WaitRequest
		);
	
	Trace.AvalonDown <= AvalonDown;
	Trace.AvalonUp <= PreAvalonUp;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	AvalonUp <= PreAvalonUp;
	
	PreAvalonUp.ReadData <= BusDividerBlkReadData;
	
	PreAvalonUp.WaitRequest <= BusDividerBlkWaitRequest
		and not UnoccupiedAck
		and not TimeoutAck;
	
	BlockMatch <= BusDividerBlkMatch;

end;
