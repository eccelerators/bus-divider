-- Copyright (C) 2023 Eccelerators GmbH
-- 
-- This code was generated by:
--
-- HxS Compiler 1.0.19-10671667
-- VHDL Extension for HxS 1.0.21-b962bd24
-- 
-- Further information at https://eccelerators.com/hxs
-- 
-- Changes to this file may cause incorrect behavior and will be lost if the
-- code is regenerated.
library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.BusDividerIfcPackage.all;

entity BusDividerBlk_BusDividerIfc is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Adr : in std_logic_vector(8 downto 0);
		Sel : in std_logic_vector(3 downto 0);
		DatIn : in std_logic_vector(31 downto 0);
		We : in std_logic;
		Stb : in std_logic;
		Cyc : in  std_logic;
		DatOut : out std_logic_vector(31 downto 0);
		Ack : out std_logic;
		Match : out std_logic;
		BusDelegate0Adr : out std_logic_vector(8 downto 0);
		BusDelegate0Sel : out std_logic_vector(3 downto 0);
		BusDelegate0We : out std_logic;
		BusDelegate0Stb : out std_logic;
		BusDelegate0DatOut : out std_logic_vector(31 downto 0);
		BusDelegate0DatIn: in std_logic_vector(31 downto 0);
		BusDelegate0Ack : in std_logic;
		BusDelegate0Cyc : out std_logic;
		BusDelegate1Adr : out std_logic_vector(8 downto 0);
		BusDelegate1Sel : out std_logic_vector(3 downto 0);
		BusDelegate1We : out std_logic;
		BusDelegate1Stb : out std_logic;
		BusDelegate1DatOut : out std_logic_vector(31 downto 0);
		BusDelegate1DatIn: in std_logic_vector(31 downto 0);
		BusDelegate1Ack : in std_logic;
		BusDelegate1Cyc : out std_logic
	);
end;

architecture Behavioural of BusDividerBlk_BusDividerIfc is

	signal PreDatOut : std_logic_vector(31 downto 0);
	signal PreDatOutBusDelegate0 : std_logic_vector(31 downto 0);
	signal PreAckBusDelegate0 : std_logic;
	signal PreMatchReadBusDelegate0 : std_logic;
	signal PreMatchWriteBusDelegate0 : std_logic;
	
	signal PreDatOutBusDelegate1 : std_logic_vector(31 downto 0);
	signal PreAckBusDelegate1 : std_logic;
	signal PreMatchReadBusDelegate1 : std_logic;
	signal PreMatchWriteBusDelegate1 : std_logic;

begin

	DatOut <= PreDatOut;
	
	Match <= PreMatchReadBusDelegate0 or PreMatchWriteBusDelegate0
		  or PreMatchReadBusDelegate1 or PreMatchWriteBusDelegate1;
	
	Ack <= PreAckBusDelegate0
		or PreAckBusDelegate1;
	
	PreDatOutMux: process (
		PreDatOutBusDelegate0,
		PreMatchReadBusDelegate0,
		PreAckBusDelegate0,
		PreDatOutBusDelegate1,
		PreMatchReadBusDelegate1,
		PreAckBusDelegate1
	) begin
		PreDatOut <= (others => '0');
		if (PreMatchReadBusDelegate0 = '1' and PreAckBusDelegate0 = '1') then
			PreDatOut <= std_logic_vector(resize(unsigned(PreDatOutBusDelegate0), PreDatOut'LENGTH));
		elsif (PreMatchReadBusDelegate1 = '1' and PreAckBusDelegate1 = '1') then
			PreDatOut <= std_logic_vector(resize(unsigned(PreDatOutBusDelegate1), PreDatOut'LENGTH));
		end if;
	end process;
	
	PreMatchReadBusDelegate0Process : process (Adr, We, Stb, Cyc)
	begin
		if ((unsigned(Adr) >= unsigned(BUSDELEGATE0_BASE_ADDRESS)) and
			(unsigned(Adr) <= (unsigned(BUSDELEGATE0_BASE_ADDRESS) + unsigned(BUSDELEGATE0_SIZE) - 1))) then
			PreMatchReadBusDelegate0 <= not We and Stb and Cyc;
		else
			PreMatchReadBusDelegate0 <= '0';
		end if;
	end process;
	
	PreMatchWriteBusDelegate0Process : process (Adr, We, Stb, Cyc)
	begin
		if ((unsigned(Adr) >= unsigned(BUSDELEGATE0_BASE_ADDRESS)) and
			(unsigned(Adr) <= (unsigned(BUSDELEGATE0_BASE_ADDRESS) + unsigned(BUSDELEGATE0_SIZE) - 1))) then
			PreMatchWriteBusDelegate0 <= We and Stb and Cyc;
		else
			PreMatchWriteBusDelegate0 <= '0';
		end if;
	end process;
	
	BusDelegate0CycProcess : process (Adr, We, Stb, Cyc)
	begin
		if ((unsigned(Adr) >= unsigned(BUSDELEGATE0_BASE_ADDRESS)) and
			(unsigned(Adr) <= (unsigned(BUSDELEGATE0_BASE_ADDRESS) + unsigned(BUSDELEGATE0_SIZE) - 1))) then
			BusDelegate0Cyc <= Cyc;
		else
			BusDelegate0Cyc <= '0';
		end if;
	end process;
	
	PreDatOutBusDelegate0 <= BusDelegate0DatIn;
	PreAckBusDelegate0 <= BusDelegate0Ack;
	BusDelegate0Adr <= Adr;
	BusDelegate0Sel <= Sel;
	BusDelegate0We <= We;
	BusDelegate0Stb <= Stb;
	BusDelegate0DatOut <= DatIn;
	
	PreMatchReadBusDelegate1Process : process (Adr, We, Stb, Cyc)
	begin
		if ((unsigned(Adr) >= unsigned(BUSDELEGATE1_BASE_ADDRESS)) and
			(unsigned(Adr) <= (unsigned(BUSDELEGATE1_BASE_ADDRESS) + unsigned(BUSDELEGATE1_SIZE) - 1))) then
			PreMatchReadBusDelegate1 <= not We and Stb and Cyc;
		else
			PreMatchReadBusDelegate1 <= '0';
		end if;
	end process;
	
	PreMatchWriteBusDelegate1Process : process (Adr, We, Stb, Cyc)
	begin
		if ((unsigned(Adr) >= unsigned(BUSDELEGATE1_BASE_ADDRESS)) and
			(unsigned(Adr) <= (unsigned(BUSDELEGATE1_BASE_ADDRESS) + unsigned(BUSDELEGATE1_SIZE) - 1))) then
			PreMatchWriteBusDelegate1 <= We and Stb and Cyc;
		else
			PreMatchWriteBusDelegate1 <= '0';
		end if;
	end process;
	
	BusDelegate1CycProcess : process (Adr, We, Stb, Cyc)
	begin
		if ((unsigned(Adr) >= unsigned(BUSDELEGATE1_BASE_ADDRESS)) and
			(unsigned(Adr) <= (unsigned(BUSDELEGATE1_BASE_ADDRESS) + unsigned(BUSDELEGATE1_SIZE) - 1))) then
			BusDelegate1Cyc <= Cyc;
		else
			BusDelegate1Cyc <= '0';
		end if;
	end process;
	
	PreDatOutBusDelegate1 <= BusDelegate1DatIn;
	PreAckBusDelegate1 <= BusDelegate1Ack;
	BusDelegate1Adr <= Adr;
	BusDelegate1Sel <= Sel;
	BusDelegate1We <= We;
	BusDelegate1Stb <= Stb;
	BusDelegate1DatOut <= DatIn;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

entity BusDividerIfcBusMonitor is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		Cyc : in  std_logic;
		Match : in std_logic;
		UnoccupiedAck : out std_logic;
		TimeoutAck : out std_logic
	);
end;

architecture Behavioural of BusDividerIfcBusMonitor is

	signal CycDelay : std_logic;
	signal PreUnoccupiedAck : std_logic;
	signal PreTimeoutAck : std_logic;
	signal TimeoutCounter : unsigned(9 downto 0);

begin

	CycDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			CycDelay <= '0';
		elsif rising_edge(Clk) then
			CycDelay <= Cyc;
		end if;
	end process;

	MatchDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreUnoccupiedAck <= '0';
		elsif rising_edge(Clk) then
			PreUnoccupiedAck <= '0';
			if ((Cyc = '1') and (CycDelay = '1') and (Match = '0')) then
				PreUnoccupiedAck <= not PreUnoccupiedAck;
			end if;
		end if;
	end process;
	
	TimeoutDetection : process (Clk, Rst)
	begin
		if (Rst = '1') then
			PreTimeoutAck <= '0';
			TimeoutCounter <= (others => '1');
		elsif rising_edge(Clk) then
			PreTimeoutAck <= '0';
			TimeoutCounter <= (others => '1');
			if ((Cyc = '1') and (CycDelay = '1') and (Match = '1')) then
				if (TimeoutCounter = 0) then
					PreTimeoutAck <= not PreTimeoutAck;
				else
					TimeoutCounter <= TimeoutCounter - 1;
				end if;
			end if;
		end if;
	end process;

	UnoccupiedAck <= PreUnoccupiedAck;
	TimeoutAck <= PreTimeoutAck;
	
end;

library ieee;
	use ieee.std_logic_1164.all;
	use ieee.numeric_std.all;

use work.BusDividerIfcPackage.all;

entity BusDividerIfcWishbone is
	port (
		Clk : in std_logic;
		Rst : in std_logic;
		WishboneDown : in T_BusDividerIfcWishboneDown;
		WishboneUp : out T_BusDividerIfcWishboneUp;
		Trace : out T_BusDividerIfcTrace;
		BusDividerBlkDown : out T_BusDividerIfcBusDividerBlkDown;
		BusDividerBlkUp : in T_BusDividerIfcBusDividerBlkUp
	);
end;

architecture Behavioural of BusDividerIfcWishbone is

	signal BlockMatch : std_logic;
	signal UnoccupiedAck : std_logic;
	signal TimeoutAck : std_logic;
	
	signal PreWishboneUp : T_BusDividerIfcWishboneUp;
	
	signal BusDividerBlkDatOut : std_logic_vector(31 downto 0);
	signal BusDividerBlkAck : std_logic;
	signal BusDividerBlkMatch : std_logic;

begin

	i_BusDividerIfcBusMonitor : entity work.BusDividerIfcBusMonitor
		port map (
			Clk => Clk,
			Rst => Rst,
			Cyc => WishboneDown.Cyc,
			Match => BlockMatch,
			UnoccupiedAck => UnoccupiedAck,
			TimeoutAck => TimeoutAck
		);
	
	i_BusDividerBlk_BusDividerIfc : entity work.BusDividerBlk_BusDividerIfc
		port map (
			Clk => Clk,
			Rst => Rst,
			Adr => WishboneDown.Adr,
			Sel => WishboneDown.Sel,
			DatIn => WishboneDown.DatIn,
			We =>  WishboneDown.We,
			Stb => WishboneDown.Stb,
			Cyc => WishboneDown.Cyc,
			DatOut => BusDividerBlkDatOut,
			Ack => BusDividerBlkAck,
			Match => BusDividerBlkMatch,
			BusDelegate0DatOut => BusDividerBlkDown.BusDelegate0DatIn,
			BusDelegate0Adr => BusDividerBlkDown.BusDelegate0Adr,
			BusDelegate0Sel => BusDividerBlkDown.BusDelegate0Sel,
			BusDelegate0We => BusDividerBlkDown.BusDelegate0We,
			BusDelegate0Stb => BusDividerBlkDown.BusDelegate0Stb,
			BusDelegate0Cyc => BusDividerBlkDown.BusDelegate0Cyc,
			BusDelegate0Ack => BusDividerBlkUp.BusDelegate0Ack,
			BusDelegate0DatIn => BusDividerBlkUp.BusDelegate0DatOut,
			BusDelegate1DatOut => BusDividerBlkDown.BusDelegate1DatIn,
			BusDelegate1Adr => BusDividerBlkDown.BusDelegate1Adr,
			BusDelegate1Sel => BusDividerBlkDown.BusDelegate1Sel,
			BusDelegate1We => BusDividerBlkDown.BusDelegate1We,
			BusDelegate1Stb => BusDividerBlkDown.BusDelegate1Stb,
			BusDelegate1Cyc => BusDividerBlkDown.BusDelegate1Cyc,
			BusDelegate1Ack => BusDividerBlkUp.BusDelegate1Ack,
			BusDelegate1DatIn => BusDividerBlkUp.BusDelegate1DatOut
		);
	
	Trace.WishboneDown <= WishboneDown;
	Trace.WishboneUp <= PreWishboneUp;
	Trace.UnoccupiedAck <= UnoccupiedAck;
	Trace.TimeoutAck <= TimeoutAck;
	
	WishboneUp <= PreWishboneUp;
	
	PreWishboneUp.DatOut <= BusDividerBlkDatOut;
	
	PreWishboneUp.Ack <= BusDividerBlkAck
		or UnoccupiedAck 
		or TimeoutAck;
	
	BlockMatch <= BusDividerBlkMatch;

end;
